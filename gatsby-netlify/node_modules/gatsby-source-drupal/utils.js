"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
exports.__esModule = true;
exports.createNodeIfItDoesNotExist = createNodeIfItDoesNotExist;
exports.drupalCreateNodeManifest = drupalCreateNodeManifest;
exports.handleDeletedNode = exports.getExtendedFileNodeData = void 0;
exports.handleReferences = handleReferences;
exports.handleWebhookUpdate = void 0;
var _difference2 = _interopRequireDefault(require("lodash/difference"));
var _isString2 = _interopRequireDefault(require("lodash/isString"));
var _cloneDeep2 = _interopRequireDefault(require("lodash/cloneDeep"));
var _isEmpty2 = _interopRequireDefault(require("lodash/isEmpty"));
var _compact2 = _interopRequireDefault(require("lodash/compact"));
var _isArray2 = _interopRequireDefault(require("lodash/isArray"));
var _each2 = _interopRequireDefault(require("lodash/each"));
var _normalize = require("./normalize");
var _pluginOptions = require("./plugin-options");
var _gatsbyCoreUtils = require("gatsby-core-utils");
var _semver = require("semver");
function makeBackRefsKey(id) {
  return `backrefs-${id}`;
}
function makeRefNodesKey(id) {
  return `refnodes-${id}`;
}
async function handleReferences(node, {
  getNode,
  mutateNode = false,
  createNodeId,
  entityReferenceRevisions = [],
  cache,
  pluginOptions
}) {
  const relationships = node.relationships;
  const rootNodeLanguage = (0, _pluginOptions.getOptions)().languageConfig ? node.langcode : `und`;
  const backReferencedNodes = [];
  if (node.drupal_relationships) {
    const referencedNodes = [];
    (0, _each2.default)(node.drupal_relationships, (v, k) => {
      if (!v.data) return;
      const nodeFieldName = `${k}___NODE`;
      if ((0, _isArray2.default)(v.data)) {
        relationships[nodeFieldName] = (0, _compact2.default)(v.data.map(data => {
          var _data$meta;
          const referencedNodeId = createNodeId((0, _normalize.createNodeIdWithVersion)({
            id: data.id,
            type: data.type,
            langcode: rootNodeLanguage,
            revisionId: (_data$meta = data.meta) === null || _data$meta === void 0 ? void 0 : _data$meta.target_version,
            entityReferenceRevisions,
            typePrefix: pluginOptions.typePrefix
          }));
          if (!getNode(referencedNodeId)) {
            return null;
          }
          referencedNodes.push(referencedNodeId);
          return referencedNodeId;
        }));
        const meta = (0, _compact2.default)(v.data.map(data => !(0, _isEmpty2.default)(data.meta) ? data.meta : null));
        // If there's meta on the field and it's not an existing/internal one
        // create a new node's field with that meta. It can't exist on both
        // @see https://jsonapi.org/format/#document-resource-object-fields
        if (!(0, _isEmpty2.default)(meta) && !(k in node)) {
          node[k] = meta;
        }
      } else {
        var _v$data$meta;
        const referencedNodeId = createNodeId((0, _normalize.createNodeIdWithVersion)({
          id: v.data.id,
          type: v.data.type,
          langcode: rootNodeLanguage,
          revisionId: (_v$data$meta = v.data.meta) === null || _v$data$meta === void 0 ? void 0 : _v$data$meta.target_revision_id,
          entityReferenceRevisions,
          typePrefix: pluginOptions.typePrefix
        }));
        if (getNode(referencedNodeId)) {
          relationships[nodeFieldName] = referencedNodeId;
          referencedNodes.push(referencedNodeId);
        }

        // If there's meta on the field and it's not an existing/internal one
        // create a new node's field with that meta. It can't exist on both
        // @see https://jsonapi.org/format/#document-resource-object-fields
        if (!(0, _isEmpty2.default)(v.data.meta) && !(k in node)) {
          node[k] = v.data.meta;
        }
      }
    });
    delete node.drupal_relationships;
    await cache.set(makeRefNodesKey(node.id), referencedNodes);
    if (referencedNodes.length) {
      const nodeFieldName = `${node.internal.type}___NODE`;
      for (const nodeId of referencedNodes) {
        let referencedNode;
        if (mutateNode) {
          referencedNode = getNode(nodeId);
        } else {
          referencedNode = (0, _cloneDeep2.default)(getNode(nodeId));
        }
        if (!referencedNode.relationships[nodeFieldName]) {
          referencedNode.relationships[nodeFieldName] = [];
        }
        if (!referencedNode.relationships[nodeFieldName].includes(node.id)) {
          referencedNode.relationships[nodeFieldName].push(node.id);
        }
        let backRefsNames = await cache.get(makeBackRefsKey(referencedNode.id));
        if (!backRefsNames) {
          backRefsNames = [];
          await cache.set(makeBackRefsKey(referencedNode.id), backRefsNames);
        }
        if (!backRefsNames.includes(nodeFieldName)) {
          backRefsNames.push(nodeFieldName);
          await cache.set(makeBackRefsKey(referencedNode.id), backRefsNames);
        }
        backReferencedNodes.push(referencedNode);
      }
    }
  }
  node.relationships = relationships;
  return backReferencedNodes;
}
const handleDeletedNode = async ({
  actions,
  node,
  getNode,
  createNodeId,
  createContentDigest,
  cache,
  entityReferenceRevisions,
  pluginOptions
}) => {
  var _node$attributes, _node$attributes2;
  let deletedNode = getNode(createNodeId((0, _normalize.createNodeIdWithVersion)({
    id: node.id,
    type: node.type,
    langcode: (0, _pluginOptions.getOptions)().languageConfig ? (_node$attributes = node.attributes) === null || _node$attributes === void 0 ? void 0 : _node$attributes.langcode : `und`,
    revisionId: (_node$attributes2 = node.attributes) === null || _node$attributes2 === void 0 ? void 0 : _node$attributes2.drupal_internal__revision_id,
    entityReferenceRevisions,
    typePrefix: pluginOptions.typePrefix
  })));

  // Perhaps the node was already deleted and Drupal is sending us references
  // to old nodes.
  if (!deletedNode) {
    return deletedNode;
  }

  // Clone node so we're not mutating the original node.
  deletedNode = (0, _cloneDeep2.default)(deletedNode);
  await cache.del(makeBackRefsKey(deletedNode.id));
  await cache.del(makeRefNodesKey(deletedNode.id));

  // Remove relationships from other nodes and re-create them.
  Object.keys(deletedNode.relationships).forEach(async key => {
    let ids = deletedNode.relationships[key];
    ids = [].concat(ids);
    for (const id of ids) {
      let node = getNode(id);

      // The referenced node might have already been deleted.
      if (node) {
        var _referencedNodes;
        // Clone node so we're not mutating the original node.
        node = (0, _cloneDeep2.default)(node);
        let referencedNodes = await cache.get(makeRefNodesKey(node.id));
        if ((_referencedNodes = referencedNodes) !== null && _referencedNodes !== void 0 && _referencedNodes.includes(deletedNode.id)) {
          // Loop over relationships and cleanup references.
          Object.entries(node.relationships).forEach(([key, value]) => {
            // If a string ref matches, delete it.
            if ((0, _isString2.default)(value) && value === deletedNode.id) {
              delete node.relationships[key];
            }

            // If it's an array, filter, then check if the array is empty and then delete
            // if so
            if (Array.isArray(value)) {
              value = value.filter(v => v !== deletedNode.id);
              if (value.length === 0) {
                delete node.relationships[key];
              } else {
                node.relationships[key] = value;
              }
            }
          });

          // Remove deleted node from array of referencedNodes
          referencedNodes = referencedNodes.filter(nId => nId !== deletedNode.id);
          await cache.set(makeRefNodesKey(node.id), referencedNodes);
        }

        // Recreate the referenced node with its now cleaned-up relationships.
        if (node.internal.owner) {
          delete node.internal.owner;
        }
        if (node.fields) {
          delete node.fields;
        }
        node.internal.contentDigest = createContentDigest(node);
        actions.createNode(node);
      }
    }
  });
  actions.deleteNode(deletedNode);
  return deletedNode;
};
exports.handleDeletedNode = handleDeletedNode;
async function createNodeIfItDoesNotExist({
  nodeToUpdate,
  actions,
  createNodeId,
  createContentDigest,
  getNode,
  reporter,
  pluginOptions
}) {
  var _nodeToUpdate$meta;
  if (!nodeToUpdate) {
    reporter.warn(`The updated node was empty. The fact you're seeing this warning means there's probably a bug in how we're creating and processing updates from Drupal.

${JSON.stringify(nodeToUpdate, null, 4)}
      `);
    return;
  }
  const {
    createNode
  } = actions;
  const newNodeId = createNodeId((0, _normalize.createNodeIdWithVersion)({
    id: nodeToUpdate.id,
    type: nodeToUpdate.type,
    langcode: (0, _pluginOptions.getOptions)().languageConfig ? nodeToUpdate.langcode : `und`,
    revisionId: (_nodeToUpdate$meta = nodeToUpdate.meta) === null || _nodeToUpdate$meta === void 0 ? void 0 : _nodeToUpdate$meta.target_version,
    entityReferenceRevisions: (0, _pluginOptions.getOptions)().entityReferenceRevisions,
    typePrefix: pluginOptions.typePrefix
  }));
  const oldNode = getNode(newNodeId);
  // Node doesn't yet exist so we'll create it now.
  if (!oldNode) {
    const newNode = await (0, _normalize.nodeFromData)(nodeToUpdate, createNodeId, (0, _pluginOptions.getOptions)().entityReferenceRevisions, pluginOptions, null, reporter);
    newNode.internal.contentDigest = createContentDigest(newNode);
    createNode(newNode);
  }
}
const handleWebhookUpdate = async ({
  nodeToUpdate,
  actions,
  cache,
  createNodeId,
  createContentDigest,
  getCache,
  getNode,
  reporter
}, pluginOptions = {}) => {
  var _nodeToUpdate$links, _nodeToUpdate$links$s, _nodeToUpdate$attribu;
  if (!nodeToUpdate) {
    reporter.warn(`The updated node was empty. The fact you're seeing this warning means there's probably a bug in how we're creating and processing updates from Drupal.

${JSON.stringify(nodeToUpdate, null, 4)}
      `);
    return;
  }
  reporter.log(`[drupal]: handling update to:
    - entity href: ${(_nodeToUpdate$links = nodeToUpdate.links) === null || _nodeToUpdate$links === void 0 ? void 0 : (_nodeToUpdate$links$s = _nodeToUpdate$links.self) === null || _nodeToUpdate$links$s === void 0 ? void 0 : _nodeToUpdate$links$s.href}
    - node id: ${(_nodeToUpdate$attribu = nodeToUpdate.attributes) === null || _nodeToUpdate$attribu === void 0 ? void 0 : _nodeToUpdate$attribu.drupal_internal__nid}
`);
  const {
    createNode,
    unstable_createNodeManifest
  } = actions;
  const newNode = await (0, _normalize.nodeFromData)(nodeToUpdate, createNodeId, pluginOptions.entityReferenceRevisions, pluginOptions, null, reporter);
  drupalCreateNodeManifest({
    attributes: nodeToUpdate.attributes,
    gatsbyNode: newNode,
    unstable_createNodeManifest
  });
  const nodesToUpdate = [newNode];
  const oldNodeReferencedNodes = await cache.get(makeRefNodesKey(newNode.id));
  const backReferencedNodes = await handleReferences(newNode, {
    getNode,
    mutateNode: false,
    createNodeId,
    cache,
    entityReferenceRevisions: pluginOptions.entityReferenceRevisions,
    pluginOptions
  });
  nodesToUpdate.push(...backReferencedNodes);
  let oldNode = getNode(newNode.id);
  if (oldNode) {
    // Clone node so we're not mutating the original node.
    oldNode = (0, _cloneDeep2.default)(oldNode);
    // copy over back references from old node
    const backRefsNames = await cache.get(makeBackRefsKey(oldNode.id));
    if (backRefsNames) {
      await cache.set(makeBackRefsKey(newNode.id), backRefsNames);
      backRefsNames.forEach(backRefFieldName => {
        newNode.relationships[backRefFieldName] = oldNode.relationships[backRefFieldName];
      });
    }
    const newNodeReferencedNodes = await cache.get(makeRefNodesKey(newNode.id));
    // see what nodes are no longer referenced and remove backRefs from them
    let removedReferencedNodes = (0, _difference2.default)(oldNodeReferencedNodes, newNodeReferencedNodes).map(id => getNode(id));
    removedReferencedNodes = removedReferencedNodes.map(node => {
      if (node) {
        return (0, _cloneDeep2.default)(node);
      } else {
        return node;
      }
    });
    nodesToUpdate.push(...removedReferencedNodes);
    const nodeFieldName = `${newNode.internal.type}___NODE`;
    removedReferencedNodes.forEach(referencedNode => {
      if (referencedNode.relationships && referencedNode.relationships[nodeFieldName]) {
        referencedNode.relationships[nodeFieldName] = referencedNode.relationships[nodeFieldName].filter(id => id !== newNode.id);
      }
    });
  }

  // Download file.
  const {
    skipFileDownloads,
    typePrefix
  } = pluginOptions;
  if ((0, _normalize.isFileNode)(newNode, typePrefix) && !skipFileDownloads) {
    await (0, _normalize.downloadFile)({
      node: newNode,
      cache,
      createNode,
      createNodeId,
      getCache
    }, pluginOptions);
  }
  for (const node of nodesToUpdate) {
    if (node.internal.owner) {
      delete node.internal.owner;
    }
    if (node.fields) {
      delete node.fields;
    }
    node.internal.contentDigest = createContentDigest(node);
    createNode(node);
    reporter.log(`Updated Gatsby node — id: ${node.id} type: ${node.internal.type}`);
  }
};
exports.handleWebhookUpdate = handleWebhookUpdate;
const GATSBY_VERSION_MANIFEST_V2 = `4.3.0`;
const gatsbyVersion = typeof _gatsbyCoreUtils.getGatsbyVersion === `function` && (0, _gatsbyCoreUtils.getGatsbyVersion)() || `0.0.0`;
const gatsbyVersionIsPrerelease = (0, _semver.prerelease)(gatsbyVersion);
const shouldUpgradeGatsbyVersion = (0, _semver.lt)(gatsbyVersion, GATSBY_VERSION_MANIFEST_V2) && !gatsbyVersionIsPrerelease;
let warnOnceForNoSupport = false;
let warnOnceToUpgradeGatsby = false;

/**
 * This fn creates node manifests which are used for Gatsby Cloud Previews via the Content Sync API/feature.
 * Content Sync routes a user from Drupal to a page created from the entry data they're interested in previewing.
 */
function drupalCreateNodeManifest({
  attributes,
  gatsbyNode,
  unstable_createNodeManifest
}) {
  const isPreview = process.env.NODE_ENV === `development` && process.env.ENABLE_GATSBY_REFRESH_ENDPOINT || process.env.GATSBY_IS_PREVIEW === `true`;
  const updatedAt = attributes === null || attributes === void 0 ? void 0 : attributes.revision_timestamp;
  const id = attributes === null || attributes === void 0 ? void 0 : attributes.drupal_internal__nid;
  const langcode = attributes === null || attributes === void 0 ? void 0 : attributes.langcode;
  const supportsContentSync = typeof unstable_createNodeManifest === `function`;
  const shouldCreateNodeManifest = id && updatedAt && supportsContentSync && isPreview;
  if (shouldCreateNodeManifest) {
    if (shouldUpgradeGatsbyVersion && !warnOnceToUpgradeGatsby) {
      console.warn(`Your site is doing more work than it needs to for Preview, upgrade to Gatsby ^${GATSBY_VERSION_MANIFEST_V2} for better performance`);
      warnOnceToUpgradeGatsby = true;
    }
    const manifestId = `${id}-${updatedAt}-${langcode}`;
    unstable_createNodeManifest({
      manifestId,
      node: gatsbyNode,
      updatedAtUTC: updatedAt
    });
  } else if (!supportsContentSync && !warnOnceForNoSupport) {
    warnOnceForNoSupport = true;
    console.warn(`Drupal: Your version of Gatsby core doesn't support Content Sync (via the unstable_createNodeManifest action). Please upgrade to the latest version to use Content Sync in your site.`);
  }
}

/**
 * This FN returns a Map with additional file node information that Drupal doesn't return on actual file nodes (namely the width/height of images)
 */
const getExtendedFileNodeData = allData => {
  const fileNodesExtendedData = new Map();
  for (const contentType of allData) {
    if (!contentType) {
      continue;
    }
    contentType.data.forEach(node => {
      if (!node) {
        return;
      }
      const {
        relationships
      } = node;
      if (relationships) {
        for (const relationship of Object.values(relationships)) {
          const relationshipNodes = Array.isArray(relationship.data) ? relationship.data : [relationship.data];
          relationshipNodes.forEach(relationshipNode => {
            if (!relationshipNode) {
              return;
            }
            if (relationshipNode.type === `file--file` && relationshipNode.meta) {
              const existingExtendedData = fileNodesExtendedData.get(relationshipNode.id);

              // if we already have extended data for this file node, we need to merge the new data with it
              if (existingExtendedData) {
                var _existingExtendedData, _relationshipNode$met, _relationshipNode$met2;
                const existingImageDerivativeLinks = (existingExtendedData === null || existingExtendedData === void 0 ? void 0 : (_existingExtendedData = existingExtendedData.imageDerivatives) === null || _existingExtendedData === void 0 ? void 0 : _existingExtendedData.links) || {};
                const imageDerivativeLinks = {
                  ...existingImageDerivativeLinks,
                  ...(((_relationshipNode$met = relationshipNode.meta) === null || _relationshipNode$met === void 0 ? void 0 : (_relationshipNode$met2 = _relationshipNode$met.imageDerivatives) === null || _relationshipNode$met2 === void 0 ? void 0 : _relationshipNode$met2.links) || {})
                };
                const newMeta = {
                  ...existingExtendedData,
                  ...relationshipNode.meta
                };
                newMeta.imageDerivatives = {
                  ...newMeta.imageDerivatives,
                  links: imageDerivativeLinks
                };
                fileNodesExtendedData.set(relationshipNode.id, newMeta);
              } else {
                // otherwise we just add the extended data to the map
                fileNodesExtendedData.set(relationshipNode.id, relationshipNode.meta);
              }
            }
          });
        }
      }
    });
  }
  return fileNodesExtendedData;
};
exports.getExtendedFileNodeData = getExtendedFileNodeData;